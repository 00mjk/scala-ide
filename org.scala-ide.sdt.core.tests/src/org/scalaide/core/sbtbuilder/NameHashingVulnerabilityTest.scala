package org.scalaide.core.sbtbuilder

import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.IncrementalProjectBuilder
import org.eclipse.core.runtime.IPath
import org.eclipse.core.runtime.NullProgressMonitor
import org.eclipse.jdt.core.IClasspathEntry
import org.eclipse.jdt.core.IJavaModelMarker
import org.eclipse.jdt.core.IJavaProject
import org.eclipse.jdt.core.JavaCore
import org.junit.AfterClass
import org.junit.Assert
import org.junit.BeforeClass
import org.junit.Test
import org.scalaide.core.IScalaProject
import org.scalaide.core.SdtConstants
import org.scalaide.core.testsetup.IProjectHelpers
import org.scalaide.core.testsetup.IProjectOperations
import org.scalaide.core.testsetup.SDTTestUtils.createProjectInWorkspace
import org.scalaide.core.testsetup.SDTTestUtils.findProjectProblemMarkers
import org.scalaide.core.testsetup.SDTTestUtils.markersMessages
import org.scalaide.core.testsetup.SDTTestUtils.workspace
import org.scalaide.ui.internal.preferences.ScalaPluginSettings
import org.scalaide.util.eclipse.EclipseUtils
import org.scalaide.util.internal.SettingConverterUtil

import NameHashingVulnerabilityTest.project

object NameHashingVulnerabilityTest extends IProjectOperations {
  import org.scalaide.core.testsetup.SDTTestUtils._
  private val projectName = "nameHashingVulnerability"
  private var project: IScalaProject = _
  private val bundleName = "org.scala-ide.sdt.core.tests"

  private def withSrcOutputStructure(project: IProject, jProject: IJavaProject): Seq[IClasspathEntry] = {
    val mainSourceFolder = project.getFolder("/src/main")
    val mainOutputFolder = project.getFolder("/target/main")
    val testSourceFolder = project.getFolder("/src/test")
    val testOutputFolder = project.getFolder("/target/test")
    Seq(mainSourceFolder -> mainOutputFolder,
      testSourceFolder -> testOutputFolder).map {
        case (src, out) => JavaCore.newSourceEntry(
          jProject.getPackageFragmentRoot(src).getPath,
          Array[IPath](),
          jProject.getPackageFragmentRoot(out).getPath)
      }
  }

  @BeforeClass def setup(): Unit = {
    initializeProjects(bundleName, Seq(projectName)) {
      project = createProjectInWorkspace(projectName, withSrcOutputStructure _)
    }
  }

  @AfterClass def cleanup(): Unit = {
    EclipseUtils.workspaceRunnableIn(EclipseUtils.workspaceRoot.getWorkspace) { _ =>
      project.underlying.delete( /* force = */ true, /* monitor = */ null)
    }
  }
}

class NameHashingVulnerabilityTest extends IProjectOperations with IProjectHelpers {
  import NameHashingVulnerabilityTest._
  private val On = true
  private val Off = false
  private val errorTypes = Array(SdtConstants.ProblemMarkerId, IJavaModelMarker.JAVA_MODEL_PROBLEM_MARKER)

  @Test def shouldCorrectlyBuildProjectForAllPossibleSettingsOfNameHashingFlag(): Unit = {
    givenCleanWorkspaceForProjects(project)

    whenNameHashingIs(Off)(thenThereIsNoErrors)

    whenNameHashingIs(On)(thenThereIsNoErrors)
  }

  private def thenThereIsNoErrors(): Unit = {
    val errors = markersMessages(findProjectProblemMarkers(project, errorTypes: _*).toList)
    Assert.assertTrue("no error expected: " + errors.mkString(", "), errors.isEmpty)
  }

  private def whenNameHashingIs(isOn: Boolean)(otherwise: => Unit): Unit = {
    val nameHashingProperty = SettingConverterUtil.convertNameToProperty(ScalaPluginSettings.nameHashing.name)
    project.storage.setValue(nameHashingProperty, isOn)
    workspace.build(IncrementalProjectBuilder.CLEAN_BUILD, new NullProgressMonitor)
    workspace.build(IncrementalProjectBuilder.FULL_BUILD, new NullProgressMonitor)
    otherwise
  }
}
